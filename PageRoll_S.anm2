--[[
MIT License
Copyright (c) 2025 sigma-axis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

https://mit-license.org/
]]

--information:PageRoll_S v1.11 (for beta22a) by σ軸
--label:変形
--track@distance:距離,0,4000,0,0.01
--track@angle:角度,-720,720,-90,0.01
--track@width:太さ,8,4000,80,0.01
--group:カメラ設定,false
--track0:視点X,-4000,4000,0,0.01
--track1:視点Y,-4000,4000,0,0.01
--track@fov:視野角,0,120,70,0.01
--group
--track@shadow:陰影,0,100,50,0.01
--check@unbound:領域外も描画,true
--group:裏地設定,false
--file@file_image:裏地画像
--select@back_orient:裏地向き=0,通常=0,左右反転=1,上下反転=2,180°反転=3
--group:その他,false
--value@PI:PI,{}
--[[pixelshader@apply:
Texture2D img : register(t0);
Texture2D back : register(t1);
cbuffer constant0 : register(b0) {
	float2 size, offset, dir, tilt_z, view_center,
		back_x, back_y;
	float radius, hf_width, tan_hf_roll, shadow;
};
float4 thicken(float4 col, float density)
{
	const float r = col.a < 1.0 / 1024 ? density * (1 - col.a) :
		(1 - pow(max(1 - col.a, 0), density)) / col.a;
	return r * col;
}
float4 blend(float4 col_base, float4 col_over)
{
	return (1 - col_over.a) * col_base + col_over;
}

float4 pick(float2 pos, Texture2D src)
{
	const int2 ipos = floor(pos - 0.5);
	pos -= ipos + 0.5;
	return lerp(
		lerp(src.Load(int3(ipos + int2(0, 0), 0)), src.Load(int3(ipos + int2(1, 0), 0)), pos.x),
		lerp(src.Load(int3(ipos + int2(0, 1), 0)), src.Load(int3(ipos + int2(1, 1), 0)), pos.x),
		pos.y);
}
float4 pick_back(float2 pos)
{
	return pick(float2(
		dot(back_x, float2(pos.x, 1)),
		dot(back_y, float2(pos.y, 1))),
	back);
}
float4 apply(float4 pos : SV_Position) : SV_Target
{
	const float2 pos0 = pos.xy - offset;
	const float l = dot(dir, pos0 - view_center);
	float4 col = l >= 0 ? img.Load(int3(pos0 - 0.5, 0)) : 0;

	if (-hf_width <= l && l <= hf_width) {
		static const float pi = 3.141592653589793;
		const float r = abs(l / radius), s = r * tan_hf_roll,
			a00 = atan(s), a01 = acos(min((r - s) / sqrt(1 + s * s), 1)),
			a1 = l < 0 ? pi / 2 + a00 - a01 : 1.5 * pi - a00 + a01,
			a2 = l < 0 ? pi / 2 + a00 + a01 : 1.5 * pi - a00 - a01,
			z1 = radius * (1 - cos(a1)), z2 = radius * (1 - cos(a2)),
			h = sqrt(max(1 - l * l / (hf_width * hf_width), 0)),
			sh = 1 - (1 - h) * shadow,
			density = 1 / max(h, 1.0 / 1024);

		const float2 pt0 = pos0 - l * dir,
			tilt_z0 = dot(tilt_z, pos0 - view_center) * tilt_z,
			roll = -2 * pi * radius * dir;
		float4 col_b = 0, col_f = 0;
		for (float2 pt = pt0 - a1 * radius * dir - z1 * tilt_z0;
			all(roll < 0 ? pt >= -0.5 : pt < size + 0.5);
			pt += roll)
			col_b = blend(col_b, thicken(pick(pt, img), density));
		for (pt = pt0 - a2 * radius * dir - z2 * tilt_z0;
			all(roll < 0 ? pt >= -0.5 : pt < size + 0.5);
			pt += roll)
			col_f = blend(thicken(pick_back(pt), density), col_f);

		col_b.rgb *= sh;
		col_b = blend(col_b, col_f);
		col_b.rgb *= sh;
		col_b *= saturate(hf_width - abs(l));
		col = blend(col, col_b);
	}
	return col;
}
]]
local obj, math, tonumber, type, unpack = obj, math, tonumber, type, unpack;

-- set anchors.
obj.setanchor("track", 0, "line");

-- take parameters.
--[==[
	PI = {
		distance:		number?,
		angle:			number?,
		width:			number?,
		X:				number?,
		Y:				number?,
		fov:			number?,
		shadow:			number?,
		unbound:		boolean|number|nil,
		backface:		number?,
		file_image:		string?,
		back_orient:	number?,
	}
]==]
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end
distance = tonumber(PI.distance) or distance;
angle = tonumber(PI.angle) or angle;
width = tonumber(PI.width) or width;
local X = tonumber(PI.X) or obj.track0;
local Y = tonumber(PI.Y) or obj.track1;
fov = tonumber(PI.fov) or fov;
shadow = tonumber(PI.shadow) or shadow;
unbound = as_bool(PI.unbound, unbound);
local backface = tonumber(PI.backface) or 1;
file_image = type(PI.file_image) == "string" and PI.file_image or file_image;
if PI.back_orient then
	local name2num = {
		[0] = 0, 1, 2, 3;
		["通常"] = 0, ["左右反転"] = 1, ["上下反転"] = 2, ["180°反転"] = 3
	};
	back_orient = name2num[PI.back_orient] or back_orient;
end

-- normalize parameters.
distance = math.max(distance, 0);
angle = math.pi / 180 * angle;
width = math.max(width, 8);
X, Y = X + obj.w / 2, Y + obj.h / 2;
fov = math.min(math.max(math.pi / 180 * fov, 0), (2 / 3) * math.pi);
shadow = math.min(math.max(shadow / 100, 0), 1);
backface = math.min(math.max(math.floor(0.5 + backface), 0), 3); -- 0: object, 1: file_image, 2: framebuffer, 3: tempbuffer.
if #file_image < 4 then
	-- no valid file name.
	if backface == 1 then backface = 0 end
end
back_orient = math.min(math.max(math.floor(0.5 + back_orient), 0), 3);

-- early return for trivial cases.
if distance == 0 then return end

-- further calculations.
local w, h = obj.w, obj.h;
local c, s = math.cos(angle), math.sin(angle);
local pos_x, pos_y =
	w / 2 - (s > 0 and 1 or -1) * w / 2 + s * distance,
	h / 2 + (c > 0 and 1 or -1) * h / 2 - c * distance;
local d = c * (X - pos_x) + s * (Y - pos_y);
pos_x, pos_y = pos_x + d * c, pos_y + d * s;
local fov_rate = math.tan(fov / 2);
local D = (w ^ 2 + h ^ 2) ^ 0.5;
local tilt_z = (2 / D * fov_rate) ^ 0.5;
local rad_rate = (width / D) * fov_rate;
rad_rate = 1 / (rad_rate + (rad_rate ^ 2 + 1) ^ 0.5); -- 1/(tan(t)+cos(t)), where tan(t) = width * tan(fov/2).
local radius = rad_rate * width / 2;

-- calculate the extension of the region.
local L, R, T, B = 0, 0, 0, 0;
if unbound and distance > 0 then
	-- track the path of the rolled paper.
	local ts, u0 = {}, s * pos_x - c * pos_y;
	if u0 > 0 then ts[#ts + 1] = 0 end
	if u0 - s * w > 0 then ts[#ts + 1] = c * w end
	if u0 + c * h > 0 then ts[#ts + 1] = s * h end
	if u0 - s * w + c * h > 0 then ts[#ts + 1] = c * w + s * h end
	if s ~= 0 then
		local x = u0 / s;
		if 0 < x and x < w then ts[#ts + 1] = c * x end
		x = (c * h + u0) / s;
		if 0 < x and x < w then ts[#ts + 1] = c * x + s * h end
	end
	if c ~= 0 then
		local y = -u0 / c;
		if 0 < y and y < h then ts[#ts + 1] = s * y end
		y = (s * w - u0) / c;
		if 0 < y and y < h then ts[#ts + 1] = c * w + s * y end
	end

	if #ts > 0 then
		-- calculate the visible size of the rolled part.
		local tm, tM, t0, r =
			math.min(unpack(ts)), math.max(unpack(ts)), c * pos_x + s * pos_y,
			1 / (1 - 2 * ((1 - math.cos(math.min(math.pi, distance / radius))) * radius / D) * fov_rate);
		L, R, T, B =
			r * c * (tm - t0), r * c * (tM - t0),
			r * s * (tm - t0), r * s * (tM - t0);
		local width2 = math.min(width / 2, r * math.sin(math.min(math.pi / 2, distance / radius)) * radius);
		if L > R then L, R = R, L end
		if T > B then T, B = B, T end
		L, R, T, B =
			L - math.abs(s) * width2 + pos_x, R + math.abs(s) * width2 + pos_x,
			T - math.abs(c) * width2 + pos_y, B + math.abs(c) * width2 + pos_y;

		-- convert to the extension size.
		L, R, T, B =
			math.max(math.ceil(-L), 0),
			math.max(math.ceil(R - w), 0),
			math.max(math.ceil(-T), 0),
			math.max(math.ceil(B - h), 0);

		-- cap to the maximum size of image.
		local max_w, max_h = obj.getinfo("image_max");
		if L + w + R > max_w then
			local M = math.floor((max_w - w) / 2);
			if L < M then R = 2 * M - L;
			elseif R < M then L = 2 * M - R;
			else L, R = M, M end
		end
		if T + h + B > max_h then
			local M = math.floor((max_h - h) / 2);
			if T < M then B = 2 * M - T;
			elseif B < M then T = 2 * M - B;
			else T, B = M, M end
		end
	end
end

-- load the image if specified.
local obj_props = { obj.ox, obj.oy, obj.oz, obj.cx, obj.cy, obj.cz, obj.rx, obj.ry, obj.rz, obj.zoom, obj.aspect, obj.alpha };
local cache_name = "cache:pageroll_s/obj";
local has_image, img_x, img_x0, img_y, img_y0 = backface > 0, 1, 0, 1, 0;
if has_image then
	obj.copybuffer(cache_name, "object");

	-- try loading the specified image.
	if backface == 1 then
		obj.load("image", file_image);
		has_image = obj.w > 0 and obj.h > 0;
	else
		has_image = obj.copybuffer("object",
			backface == 2 and "framebuffer" or "tempbuffer");
	end
	if not has_image then
		-- no valid image.
		obj.copybuffer("object", cache_name);
	end

	-- crop to match the aspect ratio.
	if obj.w * h < obj.h * w then
		local dh = math.min(math.floor(0.5 + obj.h - obj.w * h / w), obj.h - 1);
		if dh > 0 then
			local dh2 = math.floor(dh / 2);
			obj.effect("クリッピング", "上", dh - dh2, "下", dh2);
		end
	else
		local dw = math.min(math.floor(0.5 + obj.w - obj.h * w / h), obj.w - 1);
		if dw > 0 then
			local dw2 = math.floor(dw / 2);
			obj.effect("クリッピング", "左", dw - dw2, "右", dw2);
		end
	end
	img_x, img_y = obj.w / w, obj.h / h;
end

-- handle the orientation.
if back_orient % 2 == 1 then img_x, img_x0 = -img_x, w * img_x end
if back_orient >= 2 then img_y, img_y0 = -img_y, h * img_y end

-- draw by shader.
obj.setoption("drawtarget", "tempbuffer", L + w + R, T + h + B);
obj.pixelshader("apply", "tempbuffer", { has_image and cache_name or "object", "object" }, {
	w, h; L, T;
	s, -c; tilt_z * c, tilt_z * s;
	pos_x, pos_y;
	img_x, img_x0; img_y, img_y0;
	radius, width / 2, (width / D) * fov_rate * rad_rate, shadow,
});
obj.copybuffer("object", "tempbuffer");

-- adjust the center.
obj.ox, obj.oy, obj.oz, obj.cx, obj.cy, obj.cz, obj.rx, obj.ry, obj.rz, obj.zoom, obj.aspect, obj.alpha = unpack(obj_props);
obj.cx, obj.cy = obj.cx + (L - R) / 2, obj.cy + (T - B) / 2;
