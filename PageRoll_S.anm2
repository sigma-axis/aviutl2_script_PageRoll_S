--[[
MIT License
Copyright (c) 2025 sigma-axis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

https://mit-license.org/
]]

--information:PageRoll_S v1.00 (for beta12) by σ軸
--label:変形
--track@distance:距離,0,4000,0,0.01
--track@angle:角度,-720,720,-90,0.01
--track@width:太さ,8,4000,80,0.01
--track0:視点X,-4000,4000,0,0.01
--track1:視点Y,-4000,4000,0,0.01
--track@fov:視野角,0,120,70,0.01
--track@shadow:陰影,0,100,50,0.01
--check@unbound:領域外も描画,1
--value@PI:PI,{}
--[[pixelshader@apply:
Texture2D src : register(t0);
cbuffer constant0 : register(b0) {
	float2 size, dir, tilt_z, view_center;
	float radius, hf_width, tan_hf_roll, shadow;
};
float4 thicken(float4 col, float density)
{
	const float r = col.a < 1.0 / 1024 ? density * (1 - col.a) :
		(1 - pow(max(1 - col.a, 0), density)) / col.a;
	return r * col;
}
float4 blend(float4 col_base, float4 col_over)
{
	return (1 - col_over.a) * col_base + col_over;
}

float4 pick(float2 pos)
{
	const int2 ipos = floor(pos - 0.5);
	pos -= ipos + 0.5;
	return lerp(
		lerp(src.Load(int3(ipos + int2(0, 0), 0)), src.Load(int3(ipos + int2(1, 0), 0)), pos.x),
		lerp(src.Load(int3(ipos + int2(0, 1), 0)), src.Load(int3(ipos + int2(1, 1), 0)), pos.x),
		pos.y);
}
float4 apply(float4 pos : SV_Position) : SV_Target
{
	const float l = dot(dir, pos.xy - view_center);
	float4 col = { 0, 0, 0, 0 };
	if (l >= 0) col = src.Load(int3(pos.xy, 0));
	if (-hf_width > l || l > hf_width) return col;

	static const float pi = 3.141592653589793;
	const float r = abs(l / radius), s = r * tan_hf_roll,
		a00 = atan(s), a01 = acos(min((r - s) / sqrt(1 + s * s), 1)),
		a1 = l < 0 ? pi / 2 + a00 - a01 : 1.5 * pi - a00 + a01,
		a2 = l < 0 ? pi / 2 + a00 + a01 : 1.5 * pi - a00 - a01,
		z1 = radius * (1 - cos(a1)), z2 = radius * (1 - cos(a2)),
		h = sqrt(max(1 - l * l / (hf_width * hf_width), 0)),
		sh = 1 - (1 - h) * shadow,
		density = 1 / max(h, 1.0 / 1024);

	const float2 pt0 = pos.xy - l * dir,
		tilt_z0 = dot(tilt_z, pos.xy - view_center) * tilt_z,
		roll = -2 * pi * radius * dir;
	float4 col_b = { 0, 0, 0, 0 }, col_f = { 0, 0, 0, 0 };
	for (float2 pt = pt0 - a1 * radius * dir - z1 * tilt_z0;
		all(roll < 0 ? pt >= -0.5 : pt < size + 0.5); pt += roll)
		col_b = blend(col_b, thicken(pick(pt), density));
	for (pt = pt0 - a2 * radius * dir - z2 * tilt_z0;
		all(roll < 0 ? pt >= -0.5 : pt < size + 0.5); pt += roll)
		col_f = blend(thicken(pick(pt), density), col_f);

	col_b.rgb *= sh;
	col_b = blend(col_b, col_f);
	col_b.rgb *= sh;
	col_b *= saturate(hf_width - abs(l));
	return blend(col, col_b);
}
]]
local obj, math, tonumber, type, unpack = obj, math, tonumber, type, unpack;

-- set anchors.
obj.setanchor("track", 0, "line");

-- take parameters.
--[==[
	PI = {
		distance:	number?,
		angle:		number?,
		width:		number?,
		X:			number?,
		Y:			number?,
		fov:		number?,
		shadow:		number?,
		unbound:	boolean|number|nil,
	}
]==]
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end
distance = tonumber(PI.distance) or distance;
angle = tonumber(PI.angle) or angle;
width = tonumber(PI.width) or width;
local X = tonumber(PI.X) or obj.track0;
local Y = tonumber(PI.Y) or obj.track1;
fov = tonumber(PI.fov) or fov;
shadow = tonumber(PI.shadow) or shadow;
unbound = as_bool(PI.unbound, unbound ~= 0);

-- normalize parameters.
distance = math.max(distance, 0);
angle = math.pi / 180 * angle;
width = math.max(width, 8);
X, Y = X + obj.w / 2, Y + obj.h / 2;
fov = math.min(math.max(math.pi / 180 * fov, 0), (2 / 3) * math.pi);
shadow = math.min(math.max(shadow / 100, 0), 1);

-- early return for trivial cases.
if distance == 0 then return end

-- further calculations.
local c, s = math.cos(angle), math.sin(angle);
local pos_x, pos_y =
	obj.w / 2 - (s > 0 and 1 or -1) * obj.w / 2 + s * distance,
	obj.h / 2 + (c > 0 and 1 or -1) * obj.h / 2 - c * distance;
local d = c * (X - pos_x) + s * (Y - pos_y);
pos_x, pos_y = pos_x + d * c, pos_y + d * s;
local fov_rate = math.tan(fov / 2);
local D = (obj.w ^ 2 + obj.h ^ 2) ^ 0.5;
local tilt_z = (2 / D * fov_rate) ^ 0.5;
local rad_rate = (width / D) * fov_rate;
rad_rate = 1 / (rad_rate + (rad_rate ^ 2 + 1) ^ 0.5); -- 1/(tan(t)+cos(t)), where tan(t) = width * tan(fov/2).
local radius = rad_rate * width / 2;
if unbound and distance > 0 then
	-- track the path of the rolled paper.
	local ts, u0 = {}, s * pos_x - c * pos_y;
	if u0 > 0 then ts[#ts + 1] = 0 end
	if u0 - s * obj.w > 0 then ts[#ts + 1] = c * obj.w end
	if u0 + c * obj.h > 0 then ts[#ts + 1] = s * obj.h end
	if u0 - s * obj.w + c * obj.h > 0 then ts[#ts + 1] = c * obj.w + s * obj.h end
	if s ~= 0 then
		local x = u0 / s;
		if 0 < x and x < obj.w then ts[#ts + 1] = c * x end
		x = (c * obj.h + u0) / s;
		if 0 < x and x < obj.w then ts[#ts + 1] = c * x + s * obj.h end
	end
	if c ~= 0 then
		local y = -u0 / c;
		if 0 < y and y < obj.h then ts[#ts + 1] = s * y end
		y = (s * obj.w - u0) / c;
		if 0 < y and y < obj.h then ts[#ts + 1] = c * obj.w + s * y end
	end

	-- extend the region.
	if #ts > 0 then
		local L, R, T, B do
			local tm, tM, t0, r =
				math.min(unpack(ts)), math.max(unpack(ts)), c * pos_x + s * pos_y,
				1 / (1 - 2 * ((1 - math.cos(math.min(math.pi, distance / radius))) * radius / D) * fov_rate);
			L, R, T, B =
				r * c * (tm - t0), r * c * (tM - t0),
				r * s * (tm - t0), r * s * (tM - t0);
			local width2 = math.min(width / 2, r * math.sin(math.min(math.pi / 2, distance / radius)) * radius);
			if L > R then L, R = R, L end
			if T > B then T, B = B, T end
			L, R, T, B =
				L - math.abs(s) * width2 + pos_x, R + math.abs(s) * width2 + pos_x,
				T - math.abs(c) * width2 + pos_y, B + math.abs(c) * width2 + pos_y;
		end
		L, R, T, B =
			math.max(math.ceil(-L), 0),
			math.max(math.ceil(R - obj.w), 0),
			math.max(math.ceil(-T), 0),
			math.max(math.ceil(B - obj.h), 0);

		-- cap to the maximum size of image.
		local max_w, max_h = obj.getinfo("image_max");
		if L + obj.w + R > max_w then
			local M = math.floor((max_w - obj.w) / 2);
			if L < M then R = 2 * M - L;
			elseif R < M then L = 2 * M - R;
			else L, R = M, M end
		end
		if T + obj.h + B > max_h then
			local M = math.floor((max_h - obj.h) / 2);
			if T < M then B = 2 * M - T;
			elseif B < M then T = 2 * M - B;
			else T, B = M, M end
		end

		local L1, R1, T1, B1 = L, R, T, B;
		while L1 > 0 or R1 > 0 or T1 > 0 or B1 > 0 do
			-- can extend up to only 4000 pixels.
			local L2, R2, T2, B2 =
				math.min(L1, 4000), math.min(R1, 4000),
				math.min(T1, 4000), math.min(B1, 4000);
			L1, R1, T1, B1 = L1 - L2, R1 - R2, T1 - T2, B1 - B2;
			obj.effect("領域拡張","左", L2, "右", R2, "上", T2, "下", B2);
		end

		-- adjust the center and update coordinates.
		obj.cx, obj.cy = obj.cx + (L - R) / 2, obj.cy + (T - B) / 2;
		pos_x, pos_y = pos_x + L, pos_y + T;
	end
end

-- apply shader.
obj.pixelshader("apply", "object", "object", {
	obj.w, obj.h;
	s, -c; tilt_z * c, tilt_z * s;
	pos_x, pos_y;
	radius, width / 2, (width / D) * fov_rate * rad_rate, shadow,
});
